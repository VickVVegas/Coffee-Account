// prisma/schema.prisma
// Banco: PostgreSQL (recomendado). Ajuste DATABASE_URL no .env.local

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql" // ou "mysql" | "sqlite"
  url      = env("DATABASE_URL")
}

//// =========================
//// Enums
//// =========================

enum ContentType {
  GAME
  FILM
  BOOK
  ALBUM
  HQ
  RPG
}

enum LibraryStatus {
  PLAYING
  FINISHED
  WISHLIST
  DROPPED
}

enum ReactionType {
  LIKE
  USEFUL
  FUNNY
  INSIGHTFUL
  FAVORITE
}

enum SubscriptionPlan {
  INDIVIDUAL
  DUO_PLUS
  FAMILY_PLUS
  MANTIKORA
}

//// =========================
//// Usuário / Conta
//// =========================

model User {
  id           String   @id @default(cuid())
  email        String   @unique
  name         String?
  image        String?
  passwordHash String

  lang         String   @default("pt") // "pt" | "en"
  respect      Int      @default(0)

  // Relacionamentos
  reviews        Review[]
  guides         Guide[]
  library        LibraryItem[]
  respectEvents  RespectEvent[]
  achievements   Achievement[]
  notifications  Notification[]
  subscriptions  Subscription[]
  // Seguidores / seguindo
  followers      Follow[] @relation("followers")
  following      Follow[] @relation("following")

  // Follows em conteúdos
  contentFollows FollowContent[]

  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
}

//// =========================
//// Conteúdos (multi-mídia)
//// =========================

model Content {
  id          String       @id @default(cuid())
  slug        String       @unique
  title       String
  type        ContentType
  description String?
  releaseDate DateTime?
  coverUrl    String?

  // Relacionamentos
  reviews      Review[]
  guides       Guide[]
  libraryItems LibraryItem[]
  followers    FollowContent[]

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([type, releaseDate])
  @@index([title])
}

//// =========================
//// Biblioteca (user ↔ content)
//// =========================

model LibraryItem {
  id        String        @id @default(cuid())
  userId    String
  contentId String
  status    LibraryStatus @default(WISHLIST)
  notes     String?
  tags      String? // CSV simples; pode virar tabela própria depois

  user     User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  content  Content @relation(fields: [contentId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, contentId])
  @@index([status])
}

//// =========================
//// Reviews e Reações
//// =========================

model Review {
  id        String   @id @default(cuid())
  userId    String
  contentId String
  rating    Int      // 0–10 (valide na aplicação)
  text      String
  spoiler   Boolean  @default(false)

  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  content   Content  @relation(fields: [contentId], references: [id], onDelete: Cascade)
  reactions ReviewReaction[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([contentId])
  @@index([userId, contentId])
}

model ReviewReaction {
  id       String       @id @default(cuid())
  reviewId String
  userId   String
  type     ReactionType

  review Review @relation(fields: [reviewId], references: [id], onDelete: Cascade)
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@unique([reviewId, userId, type])
  @@index([userId])
}

//// =========================
//// Guias (tipo Steam Guide)
//// =========================

model Guide {
  id        String   @id @default(cuid())
  userId    String
  contentId String
  title     String
  body      String   // markdown/serialized

  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  content   Content  @relation(fields: [contentId], references: [id], onDelete: Cascade)
  reactions GuideReaction[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([contentId])
  @@index([userId])
}

model GuideReaction {
  id      String       @id @default(cuid())
  guideId String
  userId  String
  type    ReactionType

  guide Guide @relation(fields: [guideId], references: [id], onDelete: Cascade)
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@unique([guideId, userId, type])
  @@index([userId])
}

//// =========================
//// Respeito (pontuação e histórico)
//// =========================

model RespectEvent {
  id      String  @id @default(cuid())
  userId  String
  source  String  // ex.: LIKE_REVIEW, USEFUL_REVIEW, FAVORITE_REVIEW, GUIDE_USEFUL, FOLLOW_GAINED, EDITOR_FEATURED
  points  Int
  meta    Json?
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())

  @@index([userId, createdAt])
}

//// =========================
//// Conquistas / Notificações
//// =========================

model Achievement {
  id      String  @id @default(cuid())
  userId  String
  key     String  // slug único da conquista
  name    String
  meta    Json?
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())

  @@unique([userId, key])
  @@index([userId])
}

model Notification {
  id       String   @id @default(cuid())
  userId   String
  title    String
  body     String?
  read     Boolean  @default(false)
  linkUrl  String?
  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())

  @@index([userId, read])
}

//// =========================
//// Seguir: usuários e conteúdos
//// =========================

model Follow {
  id           String @id @default(cuid())
  followerId   String
  followingId  String

  follower User @relation("followers", fields: [followerId], references: [id], onDelete: Cascade)
  following User @relation("following", fields: [followingId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@unique([followerId, followingId])
  @@index([followingId])
}

model FollowContent {
  id        String  @id @default(cuid())
  userId    String
  contentId String

  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  content Content @relation(fields: [contentId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@unique([userId, contentId])
  @@index([contentId])
}

//// =========================
//// Assinaturas TEA
//// =========================

model Subscription {
  id        String           @id @default(cuid())
  userId    String
  plan      SubscriptionPlan
  active    Boolean          @default(true)
  startedAt DateTime         @default(now())
  endsAt    DateTime?        // nulo = recorrente até cancelamento
  meta      Json?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, active])
}

//// =========================
//// (Opcional) Modelos NextAuth Adapter
//// Caso queira usar sessão persistida/OAuth no futuro,
//// descomente estes modelos e configure o Adapter do NextAuth.
//// =========================
// model Account {
//   id                String  @id @default(cuid())
//   userId            String
//   type              String
//   provider          String
//   providerAccountId String
//   refresh_token     String? @db.Text
//   access_token      String? @db.Text
//   expires_at        Int?
//   token_type        String?
//   scope             String?
//   id_token          String? @db.Text
//   session_state     String?
//   user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)
//
//   @@unique([provider, providerAccountId])
// }
//
// model Session {
//   id           String   @id @default(cuid())
//   sessionToken String   @unique
//   userId       String
//   expires      DateTime
//   user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
// }
//
// model VerificationToken {
//   identifier String
//   token      String   @unique
//   expires    DateTime
//
//   @@unique([identifier, token])
// }
